---
layout: article
title: 1010. Pairs of Songs With Total Durations Divisible by 60
tags: LeetCode 简单 数组
mathjax: true
key: 2020-05-19-leetcode-1010
---

### 解题思路

第一部分是刷数组部分的题，其中第一道就是这道，其实这道题本身不难，就是要算满足**数组里两数和能够整除60**的条件的example总数。

上手第一反应：双重循环！大力出奇迹！不过很可惜，就算这道题是简单题，也不能用暴力法解决，因为会超时的。

所以，我们需要对这道题再进行分析，找到其中的规律：数组里两数和能够整除60，但是我们并不需要对每两个数进行计算，因为我们只关心**符合条件的example总数**。因此，根据这个思路，我们可以做出如下的变换：

* 假设这两个数是a和b，满足``(a + b) % 60 == 0``的条件。

* 将这个公式进行拆分，可以得到``(a % 60 + b % 60) % 60 == 0``，也就是：a的模和b的模的和可以整除60。

* 深入理解后可以知道其实**这个和只能为0或60**，所以将其改写成``a % 60 + b % 60 == 0 || a % 60 + b % 60 == 60``。其实对数组中的每一个元素都要做一次模运算。所以，下文中提到的a和b指代的是**经过模运算之后的a和b**，其中a,b ∈ [0,60)。

* ``a + b == 0``，仅代表着a和b都为0的情况。也就是说，我们仅需要统计原数组中能整除60的数的个数，然后通过$$n \choose 2$$就可以得到满足条件的example个数。

* ``a + b == 60``，代表着a和b的和都为0的情况。举个栗子，``a = 1, b = 59``就满足我们的要求，以此类推，``a = 2, b = 58``等等。在这种情况下，我们统计满足条件的个数的方法就是：**获取a和b对应的元素数量然后相乘**，也就是说，我们需要统计原数组中模为1-59的元素的个数，每两个对应的个数相乘再相加之后，最终就得到该情况下满足条件的example个数。但是要注意，这里面有一种特殊情况，``a = 30, b = 30``其实类比于``a = 0, b = 0``的情况，所以我们通过$$n \choose 2$$得到满足条件的example个数。

### 代码解析

说实话，这个思路有点儿哈希的那味儿了，所以这道题我们采用**哈希表**的数据结构去搞。

```python
class Solution:
    def numPairsDivisibleBy60(self, time: List[int]) -> int:
        arr = [0] * 60
        num = 0

        # 把原数组的所有元素做模60运算，存到哈希表中
        for t in time:
            arr[t % 60] += 1

        # 模为0和30的数，单独拿出来算
        num += arr[0] * (arr[0] - 1) / 2 + arr[30] * (arr[30] - 1) / 2

        # 互补成60的一对数的数量乘积求和
        for i in range(29):
            num += arr[i + 1] * arr[59 - i]

        return int(num)
```

执行用时上击败了90.7%的用户，内存消耗击败了100.00%的用户。

|-----------------+------------+-----------------+----------------+----------------|
| 提交时间 | 提交结果 | 执行用时 | 内存消耗 | 语言 |
|-----------------+------------+-----------------+----------------+----------------|
| 7 小时前 | 通过 | 248 ms | 17.4 MB | Python3 |

### 延伸知识

```python
class Solution:
    def numPairsDivisibleBy60(self, time: List[int]) -> int:
        from collections import defaultdict
        hashmap = defaultdict(int)
        res = 0
        for t in time:
            if t % 60 in hashmap: res += hashmap[t % 60]
            if t % 60 == 0:
                hashmap[0] += 1
                continue
            hashmap[60 - t % 60] += 1
        return res
```

在题解区看到了一位兄弟的代码，他的思路跟我大同小异。但是我惊奇地发现，原来Python3还有``defaultdict``这种神奇的东西**[Ignorance 1]**。
网上找到一位前辈的博客专门解释了[defaultdict](https://www.cnblogs.com/herbert/archive/2013/01/09/2852843.html)，而是还是很清晰的，建议看样例代码。说句实话，这东西贼有用，mark就完事儿了！
> 在未来的日子里，由于我的无知，所以我可能要多次用到“原来Python3还有XXX这种神奇的东西”这样的句式，请别介意！所以我用[Ignorance X]来帮大家记数。
